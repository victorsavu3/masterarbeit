\chapter{Background}

\section {Parallelization}

\section {Dynamic Binary Instrumentation}

\subsection{Introduction}

Binary instrumentation is a method to analyze and alter the dynamic behavior of an application by modifying its instructions at runtime. 


By inserting monitoring code it is possible to gain insight into the state of an application at any point during its execution, allowing powerful dynamic analysis tools to be created. In contrast to static analysis, dynamic binary instrumentation focuses on a concrete execution of a program. This provides a very detailed insight into the program, but it does not exercise all possible code paths.

Dynamic binary instrumentation also makes it possible to alter the state of a running program. Tools can implement automatic fault injection \cite{faultinject}, dynamic transactional memory \cite{dynamicstm} or improve security \cite{dynamicstackprotect}.

\subsection{Implementations}
\subsubsection{Valgrind}

Valgrind \cite{valgrind} is an open-source dynamic binary instrumentation framework that is used to create a number of powerful and diverse tools. It focuses on using shadow values to implement complex tools, that are difficult to develop with other frameworks. Unfortunately simple tools need a complex implementation and have a considerable overhead.

\subsubsection{Dyninst}

Dyninst \cite{dyninst} is a framework developed at the University of Maryland that performs dynamic binary instrumentation on a target application. The goal of this project is to abstract machine code in order to create simple portable tools. Multiple tools have been implemented using Dyninst such as VampirTrace \cite{vampirtrace}.

\subsubsection{Intel Pin}

Intel Pin \cite{pin} is a instrumentation framework that can be used to build a large variety of tools for Windows and Linux. The implementation is focused on ease-of-use and provides a very simple but powerful API that allows tools to instrument any instruction in a program.

\subsection{Overhead}

\subsection{Alternatives}

Static analysis tools such as the Clang Static Analyser \cite{clang} or Coverity \cite{coverity} are able to identify potential faults in an application by inspecting its source code. This type of scrutiny considers all possible paths an application can potentially follow. This will detect problems in code that is rarely tested, but can also make it very computationally intensive. In contrast to this dynamic analysis only follows a single path trough the application, but it can find many more issues with this execution.

Code instrumentation tools such as the Intel Advisor \cite{inteladvisor} allow a software developer to insert instrumentations into the source code of the application. Running analyses on the application becomes a cycle of editing the source code, rebuilding and then running. This cycle can be too restrictive when working with an existing application that depends on a convoluted build system.

Static binary instrumentation tools such as PEBIL \cite{pebil} alter an application executable by changing the instructions contained within. The new program can then be executed normally. This method can provide some performance benefits, but not in all cases as can be seen in \cite{pebilperf}. The drawback of these tools is the lack of flexibility when instrumenting as it is not possible to change instructions at runtime.


\subsection{Intel Pin}

Pin uses a just-in-time compiler to insert code into an application efficiently. A tool must implement analysis routines that are inserted into the program and instrumentation routines that determine where the insertion will take place. This allows programmers to avoid the intermediate representation and Pin to automatically optimize the instrumentations.

\subsubsection{Fast Buffers}

Tools that perform dynamic analysis execute two separate tasks, data collection and data analysis. The Intel Pin Fast Buffering APIs \cite{pinbuffer} aim to decouple these tasks in order to reduce the overhead associated with dynamic binary instrumentation. This is implemented by collecting multiple chunks of data and processing them only when the buffer used to store them is full.



\subsection{Parceive}
\section {Data Model}
\subsection{SQLite}
\section {Visualizations}
\subsection {SVG}
\subsection {Javascript}
\subsection {Parceive UI}