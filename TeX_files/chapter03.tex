\chapter{Implementation}

\section{Introduction}

\subsection{Tools}
\subsection{Analysis}
\subsection{Visualizations}
\subsection{Workflow}
\subsection{Architecture}

\section{Concepts}

\subsection{Filtering}

By using dynamic binary instrumentation it is possible to process the entire instruction stream of an application, even dynamic libraries and setup code generated by the compiler. Recording all the actions an application performs might be an advantage, but comes at the cost of runtime overhead and a large tracing database. If a developer is not interested in analyzing the entire application the overhead and the size can be reduced by defining parts that should be ignored.

In Parceive and our implementations three types of filters are available:

\textbf{Image} represents the executable or a shared library and can be used to easily ignore code that is not being developed.

\textbf{Function} represents a routine in the executable. This can be used to filter out modules from inside the executable or shared libraries based on the naming convention of the project.

\textbf{File} allows a developer to filter functions based on the file they were defined in. This requires debug for the component that contains the function. This is also the easiest way to only consider code that has debug information.

\subsection{Tags}

Tags are used to mark interesting parts of the code and to provide input to automatic program analyses. Multiple tag types are available:

\begin{itemize}
	\item [Section] marks the boundaries of a section of code that can be executed in parallel.
	\item [SectionTask] is a task inside a section. Each task can be run in parallel to any other task. When a new task is started, the old one is ended automatically.
	\item [Pipeline] marks the boundaries of a section of code that can be executed in parallel using a pipeline architecture.
	\item [PipelineIteration] represents one iteration of the pipeline.
	\item [PipelineSection] is a section of a iteration. These sections can be run in parallel to different sections from different iterations.
\end{itemize}

\subsubsection{Controling tracing}
Filtering can reduce the amount of data gathered during a programs execution, but tags can provide an even more flexible approach. Using tags it is possible to control tracing during execution with the granularity of a line:

\begin{itemize}
	\item [IgnoreAll] stops all tracing.
	\item [IgnoreCalls] stops the tracing of calls.
	\item [IgnoreAccesses] stops the tracing of accesses.
	\item [ProcessAll] forces the tracing of everything.
	\item [ProcessCalls] forces the tracing of calls.
	\item [ProcessAccesses] starts the tracing of accesses.
\end{itemize}

In Figure \ref{cap3:contralg} we can see the algorithm used to determine whether tracing is performed.

\begin{figure}
	\begin{center}
		\begin{minted}{c}
			if (ignoreCalls)
				processCallsComputed = false;
			else if (processCalls)
				processCallsComputed = true;
			else if (interestingProgramPart)
				processCallsComputed = true;
			else
				processCallsComputed = true;
			
			if (!processCallsComputed)
				processAccessesComputed = false;
			else if (ignoreAccesses)
				processAccessesComputed = false;
			else if (processAccesses)
				processAccessesComputed = true;
			else if (interestingProgramPart)
				processAccessesComputed = true;
			else
				processAccessesComputed = false;
		\end{minted}
	\end{center}
	\caption{Algorithm to determine if tracing is performed}
	\label{cap3:contralg}
\end{figure}

\subsection{Tools}

As part of this thesis two tools have been developed: \texttt{pintool\_static.so} and \texttt{pintool\_dynamic.so}.

\subsection{Analysis}

\texttt{pintool\_dynamic.so} and the database processing analyze the information gathered during the tracing in order to provide insight into the program. 

\subsection{Visualizations}

Additional visualizations have been implemented to enable source code tagging and to display the information obtained by the analysis:

\textbf{File View}

\textbf{Tag List}

\textbf{Section View}

\textbf{Pipeline View}

Additionally existing views have been extended to provide more information about tags:

\textbf{Detail View}

\textbf{CCT View}

\subsection{Database layout}

Additional tables have been added to the parceive database to store information about tags and the layout of the source code. The \texttt{SourceLocation} table contains all locations in the code that are referenced in the debug information and can be used for tags. \texttt{Tag} 

\subsection{pintool\_static.so}
\subsubsection{Source Locations}
\subsubsection{File View}
\subsubsection{Tagging}

\subsection{pintool\_dynamic.so}
\subsubsection{Architecture}
\subsubsection{Fast buffer API}
\subsubsection{Allocation interception}
\subsubsection{Shadow Stack}
\subsubsection{Tagging implementation}
\subsubsection{Memory accesses}
\subsubsection{Reference resolution}
\subsubsection{Thread handling}
\subsubsection{Tag handling}

\section{Analysis}

\subsection{Section}
\subsubsection{Introduction}
\subsubsection{Parallelization}
\subsubsection{Dependency detection}
\subsubsection{Visualization}

\subsection{Pipeline}
\subsubsection{Introduction}
\subsubsection{Parallelization}
\subsubsection{Dependency detection}
\subsubsection{Visualization}

\subsection{Calling Context Tree}
\subsubsection{Parceive UI}
\subsubsection{Modifications}





